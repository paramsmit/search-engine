[{"tool_id":"134", "name":"ALPS - Application-Level Profile Semantics", "user":"", "details":"The purpose of Application-Level Profile Semantics (ALPS) is to document the application-level semantics of a particular implementation. This is accomplished by describing elements of response representations for a target media type. For example identifying markup elements returned (i.e. semantic HTML ala Microformats) and state transitions (i.e. HTML.A and HTML.FORM elements) that advance the state of the current application.", "post_date":"2014-04-02 16:40:11", "url":"http://amundsen.com/hypermedia/profiles/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/alps-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Semantics", "Definitions", "Data Specifications"]}, {"tool_id":"727", "name":"API Blueprint", "user":"apiaryio", "details":"API Blueprint is a documentation-oriented API description language. A couple of semantic assumptions over the plain Markdown. API Blueprint is perfect for designing your Web API and its comprehensive documentation but also for quick prototyping and collaboration. It is easy to learn and even easier to read; after all,​ it is just a form of plain text.", "post_date":"2015-05-14 12:42:22", "url":"https://github.com/apiaryio/api-blueprint/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":"629", "followers":"2155", "watchers":"2155", "tags":["Specification", "Design", "Definitions", "API Blueprint Core", "API Blueprint"]}, {"tool_id":"1088", "name":"api-blueprint", "user":"apiaryio", "details":"API Blueprint", "post_date":"2016-07-17 15:21:42", "url":"https://api.github.com/repos/apiaryio/api-blueprint", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1114", "followers":"3974", "watchers":"3974", "tags":["GitHub", "Definitions"]}, {"tool_id":"1180", "name":"api-spec-converter", "user":"stoplightio", "details":"This package helps to convert between different API specifications (Postman, Swagger, RAML, StopLigh", "post_date":"2016-07-17 22:51:09", "url":"https://api.github.com/repos/stoplightio/api-spec-converter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"3", "followers":"14", "watchers":"14", "tags":["GitHub", "Definitions", "Converter"]}, {"tool_id":"1505", "name":"api-spec-converter", "user":"lucybot", "details":"Convert API descriptions between popular formats such as OpenAPI(fka Swagger), RAML, API Blueprint, WADL, etc.", "post_date":"2017-02-17 19:32:03", "url":"https://github.com/lucybot/api-spec-converter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"23", "followers":"159", "watchers":"159", "tags":["GitHub", "Definitions"]}, {"tool_id":"87", "name":"Apiary Blueprint Parser", "user":"", "details":"A JavaScript parser of Apiary API blueprints. Uses Node.js then in browser, include the browser version of the parser in your web page or application using the script tag. To parse an API blueprint, just call the parse method and pass the blueprint as a parameter. The method will return an object representing the parsed blueprint or throw an exception if the input is invalid.", "post_date":"2013-06-12 18:42:12", "url":"https://github.com/apiaryio/blueprint-parser", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Parser", "Definitions", "API Blueprint"]}, {"tool_id":"145", "name":"APIs.json", "user":"", "details":"APIs are becoming a crucial part of the Web. Unfortunately however, it remains very difficult to determine the location of these APIs on servers around the Web. The only way to discover APIs and their properties is via human driven search through public search engines or in hand curated API Directory listings. While these methods work, neither can scale to the potentially hundreds of thousands and millions of APIs which will be published over the next few years.", "post_date":"2014-06-15 17:00:37", "url":"http://apisjson.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/apisdotjson.png", "forks":0, "followers":0, "watchers":0, "tags":["Discovery", "Definitions"]}, {"tool_id":"1464", "name":"Asset Description Metadata Schema (ADMS)", "user":"", "details":"ADMS is a profile of DCAT, used to describe&nbsp;semantic assets&nbsp;(or just Assets), defined as highly reusable metadata (e.g. xml schemata, generic data models) and reference data (e.g. code lists, taxonomies, dictionaries, vocabularies) that are used for eGovernment system development.", "post_date":"2016-12-01 11:37:14", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/w3c-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"823", "name":"Barrister RPC", "user":"", "details":"Barrister is a RPC system that uses an external interface definition (IDL) file to describe the interfaces and data structures that a component implements. It is similar to tools like Protocol Buffers, Thrift, Avro, and SOAP.", "post_date":"2015-07-30 23:36:22", "url":"http://barrister.bitmechanic.com/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/barrister-rpc.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"1199", "name":"certificate-transparency-rfcs", "user":"google", "details":"Certificate Transparency RFC", "post_date":"2016-07-17 23:23:45", "url":"https://api.github.com/repos/google/certificate-transparency-rfcs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"19", "followers":"41", "watchers":"41", "tags":["GitHub", "Encryption", "Definitions"]}, {"tool_id":"1168", "name":"chef-server-schema", "user":"chef", "details":"SQL Schema for the Open Source Chef Server", "post_date":"2016-07-17 22:39:38", "url":"https://api.github.com/repos/chef/chef-server-schema", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"1", "watchers":"1", "tags":["Schema", "GitHub", "Definitions"]}, {"tool_id":"1501", "name":"CKAN OpenAPI Spec", "user":"", "details":"", "post_date":"2017-02-13 21:00:29", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data", "CKAN"]}, {"tool_id":"155", "name":"Collection+JSON", "user":"", "details":"Collection+JSON is a JSON-based read/write hypermedia-type designed to support management and querying of simple collections.", "post_date":"2014-07-25 18:07:45", "url":"http://amundsen.com/media-types/collection/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"https://github.com/collection-json", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/madmen_icon_400x400.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"1509", "name":"connect-api-specification", "user":"square", "details":"", "post_date":"2017-02-17 19:42:08", "url":"https://github.com/square/connect-api-specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"7", "followers":"19", "watchers":"19", "tags":["OpenAPI Spec", "Implementations", "GitHub", "Definitions"]}, {"tool_id":"770", "name":"couchdb-api-blueprint", "user":"BigBlueHat", "details":"apiaryio API Blueprint of Apache CouchDBs API", "post_date":"2015-05-14 12:47:43", "url":"https://github.com/BigBlueHat/couchdb-api-blueprint/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1", "followers":"1", "watchers":"1", "tags":["GitHub", "Definitions", "Database", "CouchDB", "API Blueprint"]}, {"tool_id":"1495", "name":"CSV Dialect Description Format (CSVDDF)", "user":"", "details":"This RFC defines a simple JSON format to describe the various dialects of CSV files; it aims to deal with a reasonably large subset of the features which differ between dialects (terminator strings, quoting rules, escape rules, etc), and roughly to describe the union of the capabilities of Python&rsquo;s csv module, Ruby&rsquo;s CSV module, and the MySQL and Postgres bulk load facilities at the time of writing (February 2013).", "post_date":"2017-01-23 14:33:28", "url":"http://specs.frictionlessdata.io/csv-dialect/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Schema", "Definitions", "Data", "CSV"]}, {"tool_id":"1496", "name":"Data Package Identifiers", "user":"", "details":"Data Package Identifiers are small JSON-oriented structure or strings which identify a Data Package (and, usually, its location).", "post_date":"2017-01-23 14:34:51", "url":"http://specs.frictionlessdata.io/data-package-identifier/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Schema", "Identifiers", "Definitions", "Data"]}, {"tool_id":"1492", "name":"datapackagist", "user":"frictionlessdata", "details":"A web app for creating, editing and validating Data Packages.", "post_date":"2017-01-23 14:25:09", "url":"https://api.github.com/repos/frictionlessdata/datapackagist", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"7", "followers":"14", "watchers":"14", "tags":["GitHub", "Definitions", "Data"]}, {"tool_id":"973", "name":"Docson", "user":"lbovet", "details":"Documentation for your JSON types", "post_date":"2016-07-11 19:58:33", "url":"https://github.com/lbovet/docson", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"42", "followers":"250", "watchers":"250", "tags":["GitHub", "Definitions", "Data Specifications"]}, {"tool_id":"1467", "name":"European Union PSI Directive", "user":"", "details":"The Directive on the re-use of public sector information (Directive 2003/98/EC, known as the PSI Directive) entered into force on 31 December 2003. It was revised by Directive 2013/37/EU which entered into force on 17 July 2013. It focuses on the economic aspects of re-use of information rather than on the access of citizens to information. It encourages the Member States to make as much information available for re-use as possible. It addresses material held by public sector bodies in the Member States, at national, regional and local levels, such as&nbsp;ministries, state agencies, municipalities, as well as organisations funded for the most part by or under the control of public authorities (e.g. meteorological institutes). Since 2013 content held by museums, libraries and archives falls within the scope of application as well.", "post_date":"2016-12-01 11:44:12", "url":"https://ec.europa.eu/digital-single-market/legal-rules#revision-of-the-directive", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/european-commission.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Policy"]}, {"tool_id":"1493", "name":"Frictionless Data", "user":"", "details":"A Data Package (or DataPackage) is a coherent collection of data and possibly other assets in a single &lsquo;package&rsquo;. It provides the basis for convenient delivery, installation and management of datasets.", "post_date":"2017-01-23 14:30:37", "url":"http://specs.frictionlessdata.io/data-packages/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Definitions", "Data"]}, {"tool_id":"1465", "name":"G8 Open Data Charter", "user":"", "details":"The Open Data Charter sets out 5 strategic principles that all G8 members will act on. These include an expectation that all government data will be published openly by default, alongside principles to increase the quality, quantity and re-use of the data that is released. G8 members have also identified 14 high-value areas &ndash; from education to transport, and from health to crime and justice &ndash; from which they will release data. These will help unlock the economic potential of open data, support innovation and provide greater accountability.", "post_date":"2016-12-01 11:39:33", "url":"https://www.gov.uk/government/publications/open-data-charter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/Screen Shot 2016-12-01 at 11.40.25 AM.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Policy"]}, {"tool_id":"1534", "name":"gnostic", "user":"googleapis", "details":"Compile OpenAPI descriptions into equivalent Protocol Buffer representations. Profit.", "post_date":"2017-03-10 14:19:24", "url":"https://github.com/googleapis/gnostic", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"4", "followers":"24", "watchers":"24", "tags":["GitHub", "Design", "Definitions"]}, {"tool_id":"1511", "name":"go-swagger", "user":"go-swagger", "details":"Swagger 2.0 implementation for go", "post_date":"2017-02-17 22:26:14", "url":"https://github.com/go-swagger/go-swagger", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"224", "followers":"971", "watchers":"971", "tags":["Parser", "GitHub", "Generator", "Definitions"]}, {"tool_id":"153", "name":"HAL", "user":"", "details":"HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Adopting HAL will make your API explorable, and its documentation easily discoverable from within the API itself. In short, it will make your API easier to work with and therefore more attractive to client developers. APIs that adopt HAL can be easily served and consumed using open source libraries available for most major programming languages. Its also simple enough that you can just deal with it as you would any other JSON.", "post_date":"2014-07-25 17:27:37", "url":"http://stateless.co/hal_specification.html", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/bw-github.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"820", "name":"Home Documents for HTTP APIs", "user":"", "details":"JSON Home Document is an HTTP API definition formated that follows the RFC4627 specification, and has the media type application/json-home.", "post_date":"2015-07-30 19:12:17", "url":"http://tools.ietf.org/html/draft-nottingham-json-home-02", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/ietf-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"69", "name":"I/O Docs", "user":"", "details":"I/O Docs is a live interactive documentation system for RESTful web APIs. By defining APIs at the resource, method and parameter levels in a JSON schema, I/O Docs will generate a JavaScript client interface. API calls can be executed from this interface, which are then proxied through the I/O Docs server with payload data cleanly formatted (pretty-printed if JSON or XML).", "post_date":"2013-02-02 20:12:13", "url":"https://github.com/mashery/iodocs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/io-docs-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Definitions"]}, {"tool_id":"824", "name":"Interpol", "user":"", "details":"Interpol is a toolkit for policing your HTTP JSON interface. To use it, define the endpoints of your HTTP API in simple YAML files. Interpol provides multiple tools to work with endpoint definitions.", "post_date":"2015-07-30 23:38:45", "url":"https://github.com/seomoz/interpol", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/interpol-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"1300", "name":"interpol", "user":"seomoz", "details":"A toolkit for working with API endpoint definition files, giving you a stub app, a schema validation", "post_date":"2016-07-25 23:21:44", "url":"https://api.github.com/repos/seomoz/interpol", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"13", "followers":"187", "watchers":"187", "tags":["GitHub", "Definitions"]}, {"tool_id":"815", "name":"JSON API", "user":"", "details":"If youve​ ever argued with your team about the way your JSON responses should be formatted, JSON API is your anti-bikeshedding weapon. By following shared conventions, you can increase productivity, take advantage of generalized tooling, and focus on what matters: your application. Clients built around JSON API are able to take advantage of its features around efficiently caching responses, sometimes eliminating network requests entirely.", "post_date":"2015-07-10 18:54:07", "url":"http://jsonapi.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-api-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Design", "Definitions"]}, {"tool_id":"827", "name":"JSON Schema", "user":"", "details":"Describes your JSON data format in clear, human- and machine-readable documentation that is complete structural validation, useful for automated testing, and validating client-submitted data.", "post_date":"2015-07-30 23:49:15", "url":"http://json-schema.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-schema.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"1494", "name":"JSON Table Schema", "user":"", "details":"This RFC defines a simple schema for tabular data. The schema is designed to be expressible in JSON.", "post_date":"2017-01-23 14:31:56", "url":"http://specs.frictionlessdata.io/json-table-schema/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Schema", "Definitions", "Data Definitions", "Data"]}, {"tool_id":"1372", "name":"json-api", "user":"json-api", "details":"A specification for building JSON APIs", "post_date":"2016-08-04 18:12:37", "url":"https://github.com/json-api/json-api", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"449", "followers":"3914", "watchers":"3914", "tags":["GitHub", "Definitions"]}, {"tool_id":"167", "name":"JSON-LD", "user":"", "details":"JSON-LD is a lightweight Linked Data format. It is easy for humans to read and write. It is based on the already successful JSON format and provides a way to help JSON data interoperate at Web-scale. JSON-LD is an ideal data format for programming environments, REST Web services, and unstructured databases such as CouchDB and MongoDB.", "post_date":"2014-12-19 10:57:24", "url":"http://json-ld.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/json-ld.png", "forks":0, "followers":0, "watchers":0, "tags":["Semantics", "Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"828", "name":"JSON-RPC 2.0", "user":"", "details":"JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over http, or in many various message passing environments. It uses JSON (RFC 4627) as data format.", "post_date":"2015-07-30 23:53:52", "url":"http://www.jsonrpc.org/specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-rpc.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"1531", "name":"json-viewer", "user":"tulios", "details":"It is a Chrome extension for printing JSON and JSONP.", "post_date":"2017-03-04 21:02:03", "url":"https://github.com/tulios/json-viewer", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"103", "followers":"496", "watchers":"496", "tags":["GitHub", "Definitions"]}, {"tool_id":"1489", "name":"jsontableschema-js", "user":"frictionlessdata", "details":"A utility library for working with JSON Table Schema in Javascript.", "post_date":"2017-01-23 14:21:43", "url":"https://api.github.com/repos/frictionlessdata/jsontableschema-js", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"5", "followers":"13", "watchers":"13", "tags":["Schema", "JSON", "GitHub", "Definitions", "Data"]}, {"tool_id":"1159", "name":"loopback-connector-swagger", "user":"strongloop", "details":"Connect Loopback to a Swagger-compliant API", "post_date":"2016-07-17 22:31:38", "url":"https://api.github.com/repos/strongloop/loopback-connector-swagger", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"1", "watchers":"1", "tags":["GitHub", "Definitions"]}, {"tool_id":"825", "name":"Markdown Syntax for Object Notation (MSON)", "user":"", "details":"MSON is a plain-text, human and machine readable, description format for describing data structures in common markup formats such as JSON, XML or YAML.", "post_date":"2015-07-30 23:40:36", "url":"https://github.com/apiaryio/mson", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"168", "name":"Mason", "user":"", "details":"Mason is a JSON format for introducing hypermedia elements to classic JSON data representations. With Mason, you get hypermedia elements for linking and modifying data, features for communicating to client developers and standardized error handling. Mason is built on JSON, reads JSON, writes JSON and generally fits well into a JSON based eco-system.", "post_date":"2014-12-19 10:59:17", "url":"https://github.com/JornWildt/Mason", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/jorn-wildt.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"1119", "name":"ODataSamples", "user":"odata", "details":"Samples: For ODataLib, OData Web API, RESTier, etc.", "post_date":"2016-07-17 20:07:30", "url":"https://api.github.com/repos/OData/ODataSamples", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"76", "followers":"68", "watchers":"68", "tags":["GitHub", "Definitions"]}, {"tool_id":"821", "name":"Open Data Protocol (OData)", "user":"", "details":"OData (Open Data Protocol) is an OASIS standard that defines the best practice for building and consuming RESTful APIs. OData helps you focus on your business logic while building RESTful APIs without having to worry about the approaches to define request and response headers, status codes, HTTP methods, URL conventions, media types, payload formats and query options etc.", "post_date":"2015-07-30 22:03:30", "url":"http://www.odata.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/odata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Design", "Definitions", "Data Specifications", "Data Specification"]}, {"tool_id":"845", "name":"OpenAPI Specification", "user":"OAI", "details":"The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service.", "post_date":"2016-03-11 23:16:54", "url":"https://github.com/OAI/OpenAPI-Specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/openapi-spec.png", "forks":"940", "followers":"3107", "watchers":"3107", "tags":["Specification", "GitHub", "Design", "Definitions"]}, {"tool_id":"1504", "name":"OpenAPI-Specification", "user":"OAI", "details":"The OpenAPI Specification Repository", "post_date":"2017-02-17 19:31:51", "url":"https://github.com/OAI/OpenAPI-Specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1671", "followers":"5672", "watchers":"5672", "tags":["GitHub", "Definitions"]}, {"tool_id":"752", "name":"Paw API Blueprint Generator", "user":"apiaryio", "details":"Paw extension providing support to export API Blueprint as a code generator, allowing for you to publish API definitions from the web API client tooling.", "post_date":"2015-05-14 12:45:02", "url":"https://github.com/apiaryio/Paw-APIBlueprintGenerator/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/paw-api-client.png", "forks":"1", "followers":"10", "watchers":"10", "tags":["Generator", "Definitions", "Clients", "API Blueprint"]}, {"tool_id":"1172", "name":"Paw-PostmanEnvironmentImporter", "user":"luckymarmot", "details":"A Paw Extension to import Postman Environments.", "post_date":"2016-07-17 22:46:27", "url":"https://api.github.com/repos/luckymarmot/Paw-PostmanEnvironmentImporter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"5", "watchers":"5", "tags":["GitHub", "Definitions", "Clients"]}, {"tool_id":"1173", "name":"Paw-PostmanImporter", "user":"luckymarmot", "details":"A Paw Extension to import Postman Collections.", "post_date":"2016-07-17 22:46:42", "url":"https://api.github.com/repos/luckymarmot/Paw-PostmanImporter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"5", "watchers":"5", "tags":["GitHub", "Definitions", "Clients"]}, {"tool_id":"1171", "name":"Paw-WADLImporter", "user":"luckymarmot", "details":"WADL Importer for Paw", "post_date":"2016-07-17 22:46:04", "url":"https://api.github.com/repos/luckymarmot/Paw-WADLImporter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"0", "watchers":"0", "tags":["GitHub", "Definitions", "Clients"]}, {"tool_id":"826", "name":"Postman Collections", "user":"", "details":"A collection lets you group individual requests together. These requests can be further organized into folders to accurately mirror your API. Requests can also store sample responses when saved in a collection. You can add metadata like name and description too so that all the information that a developer needs to use your API is available easily.", "post_date":"2015-07-30 23:44:35", "url":"https://www.getpostman.com/docs/collections", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/postman-rest-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Definitions"]}, {"tool_id":"1466", "name":"President Obama Executive Order", "user":"", "details":"Under the terms of the Executive Order and a new&nbsp;Open Data Policy&nbsp;released today by the Office of Science and Technology Policy and the Office of Management and Budget, all newly generated government data will be required to be made available in open, machine-readable formats, greatly enhancing their accessibility and usefulness, while ensuring privacy and security.", "post_date":"2016-12-01 11:42:13", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/white-house-logo-2.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Policy"]}, {"tool_id":"1179", "name":"prism", "user":"stoplightio", "details":"Turn any OAS (Swagger 2) file into an API server with mocking, transformations, validations, and mor", "post_date":"2016-07-17 22:50:49", "url":"https://api.github.com/repos/stoplightio/prism", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"3", "followers":"7", "watchers":"7", "tags":["Proxy", "GitHub", "Definitions"]}, {"tool_id":"1507", "name":"public_api_specs", "user":"NYTimes", "details":"The API Specs (in OpenAPI/Swagger) for the APIs available from developer.nytimes.com", "post_date":"2017-02-17 19:32:59", "url":"https://github.com/NYTimes/public_api_specs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"11", "followers":"59", "watchers":"59", "tags":["Implementations", "GitHub", "Definitions"]}, {"tool_id":"810", "name":"RAML Specification", "user":"", "details":"RESTful API Modeling Language (RAML) is a simple and succinct way of describing practically-RESTful APIs. It encourages reuse, enables discovery and pattern-sharing, and aims for merit-based emergence of best practices. The goal is to help our current API ecosystem by solving immediate problems and then encourage ever-better API patterns. RAML is built on broadly-used standards such as YAML and JSON and is a non-proprietary, vendor-neutral open spec.", "post_date":"2015-06-30 14:05:03", "url":"http://raml.org", "blog_url":"http://blog.raml.org/", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/raml-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "RAML", "Design", "Definitions"]}, {"tool_id":"1176", "name":"raml2postman", "user":"postmanlabs", "details":"Coverts RAML specs to Postman Collections (v1 of the collection format)", "post_date":"2016-07-17 22:48:54", "url":"https://api.github.com/repos/postmanlabs/raml2postman", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"2", "followers":"12", "watchers":"12", "tags":["GitHub", "Definitions", "Conversion", "Clients"]}, {"tool_id":"1462", "name":"ReDoc", "user":"Rebilly", "details":"OpenAPI/Swagger-generated API Reference Documentation", "post_date":"2016-09-28 20:22:54", "url":"https://github.com/Rebilly/ReDoc", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"24", "followers":"217", "watchers":"217", "tags":["GitHub", "Definitions"]}, {"tool_id":"829", "name":"RESTdesc", "user":"", "details":"Semantic descriptions for hypermedia APIs. RESTdesc allows you to capture the functionality of hypermedia APIs, so automated agents can use them. Despite their powerful capabilities, RESTdesc descriptions are easy to master. The description is not a goal in itself: you want your API to be used. See how RESTdesc opens up your API for discovery, based on its functional characteristics.", "post_date":"2015-07-31 00:00:13", "url":"http://restdesc.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/restdesc-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"818", "name":"RESTful API Description Language (RADL)", "user":"", "details":"RESTful API Description Language (RADL) is an XML vocabulary for describing Hypermedia-driven RESTful APIs. Unlike most HTTP API description languages, RADL focuses on defining a truly hypermedia-driven REST API from the clients point of view. Unlike description languages based on JSON or Markdown, RADL makes it easy to integrate documentation written in HTML or XML. The APIs that RADL describes may use any media type, in XML, JSON, HTML, or any other format.", "post_date":"2015-07-11 16:49:06", "url":"https://github.com/restful-api-description-language/RADL", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/radl-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"124", "name":"RESTful API Modeling Language", "user":"", "details":"RESTful API Modeling Language (RAML) is a simple and succinct way of describing practically-RESTful APIs. It encourages reuse, enables discovery and pattern-sharing, and aims for merit-based emergence of best practices. The goal is to help our current API ecosystem by solving immediate problems and then encourage ever-better API patterns. RAML is built on broadly-used standards such as YAML and JSON and is a non-proprietary, vendor-neutral open spec.", "post_date":"2013-12-22 23:45:15", "url":"http://raml.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/raml-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Definitions"]}, {"tool_id":"822", "name":"RESTful Service Description Language (RSDL)", "user":"", "details":"The RESTful Service Description Language (RSDL) is a machine- and human-readable XML description of HTTP-based web applications (typically REST web services).", "post_date":"2015-07-30 23:12:42", "url":"http://www.balisage.net/Proceedings/vol10/html/Robie01/BalisageVol10-Robie01.html", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/rsdl-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"140", "name":"Rspec APIBlueprint", "user":"", "details":"Autogeneration of API documentation using the Blueprint format from request specs.", "post_date":"2014-06-15 13:13:42", "url":"https://github.com/playround/rspec_api_blueprint", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/api-blueprint.png", "forks":0, "followers":0, "watchers":0, "tags":["Generator", "Generation", "Definitions"]}, {"tool_id":"814", "name":"Schema.org", "user":"", "details":"Schema.org is a collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet, on web pages, in email messages, and beyond. Schema.org vocabulary can be used with many different encodings, including RDFa, Microdata and JSON-LD.", "post_date":"2015-07-10 17:39:35", "url":"http://schema.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/schema-org-logo.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Definitions"]}, {"tool_id":"1177", "name":"schemas", "user":"postmanlabs", "details":"Repository of all schemas for JSON structures compatible with Postman (such as the Postman Collectio", "post_date":"2016-07-17 22:49:13", "url":"https://api.github.com/repos/postmanlabs/schemas", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"8", "followers":"4", "watchers":"4", "tags":["Schemas", "GitHub", "Definitions"]}, {"tool_id":"1491", "name":"schemas", "user":"frictionlessdata", "details":"JSON Schemas, and a registry, for the Data Package family of specifications.", "post_date":"2017-01-23 14:24:24", "url":"https://api.github.com/repos/frictionlessdata/schemas", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"8", "followers":"16", "watchers":"16", "tags":["GitHub", "Definitions", "Data Schemas"]}, {"tool_id":"1484", "name":"serverless-swagger-plugin", "user":"serverless", "details":"", "post_date":"2017-01-13 23:17:15", "url":"https://github.com/serverless/serverless-swagger-plugin", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1", "followers":"18", "watchers":"18", "tags":["Serverless", "GitHub", "Deployment", "Definitions"]}, {"tool_id":"1485", "name":"serverless_swagger", "user":"Reckon-Limited", "details":"Configure serverless functions from swagger definition", "post_date":"2017-01-13 23:17:51", "url":"https://github.com/Reckon-Limited/serverless_swagger", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"5", "watchers":"5", "tags":["Serverless", "GitHub", "Deployment", "Definitions"]}, {"tool_id":"166", "name":"Siren", "user":"", "details":"Siren is a hypermedia specification for representing entities. As HTML is used for visually representing documents on a Web site, Siren is a specification for presenting entities via a Web API. Siren offers structures to communicate information about entities, actions for executing state transitions, and links for client navigation.", "post_date":"2014-12-19 10:54:55", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/kevin-swiber.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"1335", "name":"skinfer", "user":"scrapinghub", "details":"Skinfer is a tool for inferring and merging JSON schemas", "post_date":"2016-07-26 00:06:44", "url":"https://api.github.com/repos/scrapinghub/skinfer", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"6", "followers":"48", "watchers":"48", "tags":["Merging", "GitHub", "Definitions"]}, {"tool_id":"731", "name":"Snowcrash", "user":"apiaryio", "details":"Snow Crash is the reference API Blueprint parser built on top of the Sundown Markdown parser.", "post_date":"2015-05-14 12:42:39", "url":"https://github.com/apiaryio/snowcrash/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":"42", "followers":"265", "watchers":"265", "tags":["Parser", "GitHub", "Definitions", "API Blueprint Core", "API Blueprint"]}, {"tool_id":"1490", "name":"specs", "user":"frictionlessdata", "details":"Specifications for Frictionless Data.", "post_date":"2017-01-23 14:22:19", "url":"https://api.github.com/repos/frictionlessdata/specs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"48", "followers":"264", "watchers":"264", "tags":["GitHub", "Definitions"]}, {"tool_id":"1508", "name":"spectacle", "user":"sourcey", "details":"Beautiful static documentation generator for OpenAPI/Swagger 2.0", "post_date":"2017-02-17 19:40:21", "url":"https://github.com/sourcey/spectacle", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"16", "followers":"42", "watchers":"42", "tags":["OpenAPI Spec", "Open API Initiative", "OAI", "GitHub", "Definitions"]}, {"tool_id":"1181", "name":"swagger-editor", "user":"swagger-hub", "details":"Swagger Editor", "post_date":"2016-07-17 22:51:45", "url":"https://api.github.com/repos/swagger-hub/swagger-editor", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"0", "watchers":"0", "tags":["IDE", "GitHub", "Definitions"]}, {"tool_id":"1182", "name":"swagger-ui", "user":"swagger-hub", "details":"Swagger UI is a dependency-free collection of HTML, Javascript, and CSS assets that dynamically gene", "post_date":"2016-07-17 22:52:03", "url":"https://api.github.com/repos/swagger-hub/swagger-ui", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"0", "watchers":"0", "tags":["GitHub", "Documentation", "Definitions"]}, {"tool_id":"1178", "name":"swagger2-to-postman", "user":"postmanlabs", "details":"Converter for swagger 2.0 JSON to Postman Collection", "post_date":"2016-07-17 22:49:47", "url":"https://api.github.com/repos/postmanlabs/swagger2-to-postman", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"12", "followers":"21", "watchers":"21", "tags":["GitHub", "Definitions", "Conversion", "Clients"]}, {"tool_id":"139", "name":"Swagger2RAML", "user":"", "details":"A utility to generate RAML documentation from OpenAPI Specification.", "post_date":"2014-06-15 13:09:11", "url":"https://github.com/8x8Cloud/swagger2raml", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/raml-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Swagger", "Definitions", "Converter"]}, {"tool_id":"1486", "name":"swaggy-lambda", "user":"mjgillespie", "details":"A toolkit to make serverless swagger-based REST services simple using AWS API Gateway and Lambda", "post_date":"2017-01-13 23:18:17", "url":"https://github.com/mjgillespie/swaggy-lambda", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"2", "followers":"32", "watchers":"32", "tags":["Serverless", "GitHub", "Deployment", "Definitions"]}, {"tool_id":"1162", "name":"tyk-swagger-definitions", "user":"TykTechnologies", "details":"Tyk swagger (OpenAPI) definition files", "post_date":"2016-07-17 22:35:09", "url":"https://api.github.com/repos/TykTechnologies/tyk-swagger-definitions", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"2", "followers":"0", "watchers":"0", "tags":["OpenAPI Spec", "Management", "Implementations", "GitHub", "Gateways", "Deployment", "Definitions"]}, {"tool_id":"154", "name":"UBER", "user":"", "details":"The Uber message format is a minimal read/write hypermedia type designed to support simple state transfers and ad-hoc hypermedia-based transitions. This document describes both the XML and JSON variants of the format and provides guidelines for supporting Uber messages over the HTTP protocol.", "post_date":"2014-07-25 18:05:16", "url":"https://rawgit.com/mamund/media-types/master/uber-hypermedia.html", "blog_url":"", "blog_rss_url":"", "twitter_url":"http://twitter.com/uberhypermedia ", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/madmen_icon_400x400.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Hypermedia", "Design", "Definitions"]}, {"tool_id":"817", "name":"Web Application Description Language (WADL)", "user":"", "details":"The Web Application Description Language (WADL) is a machine-readable XML description of HTTP-based web applications (typically REST web services). WADL models the resources provided by a service and the relationships between them. WADL is intended to simplify the reuse of web services that are based on the existing HTTP architecture of the Web. It is platform and language independent and aims to promote reuse of applications beyond the basic use in a web browser.", "post_date":"2015-07-11 16:36:02", "url":"https://wadl.java.net/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wadl-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"844", "name":"Web Resource Modeling Language (WRML)", "user":"wrml", "details":"WRML, the Web Resource Modeling Language, is a domain-specific modeling language thats oriented toward the design of REST APIs.", "post_date":"2016-03-11 22:25:09", "url":"http://tool.api.kinlane.com/tool/fromgithub/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wrml-logo.png", "forks":"7", "followers":"13", "watchers":"13", "tags":["Specification", "GitHub", "Design", "Definitions"]}, {"tool_id":"816", "name":"Web Services Description Language (WSDL)", "user":"", "details":"WSDL is an XML format for describing network services as a set of endpoints operating on messages containing either document-oriented or procedure-oriented information. The operations and messages are described abstractly, and then bound to a concrete network protocol and message format to define an endpoint. Related concrete endpoints are combined into abstract endpoints (services). WSDL is extensible to allow description of endpoints and their messages regardless of what message formats or network protocols are used to communicate, however, the only bindings described in this document describe how to use WSDL in conjunction with SOAP 1.1, HTTP GET/POST, and MIME.", "post_date":"2015-07-11 16:31:23", "url":"http://www.w3.org/TR/wsdl", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wsdl-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"134", "name":"ALPS - Application-Level Profile Semantics", "user":"", "details":"The purpose of Application-Level Profile Semantics (ALPS) is to document the application-level semantics of a particular implementation. This is accomplished by describing elements of response representations for a target media type. For example identifying markup elements returned (i.e. semantic HTML ala Microformats) and state transitions (i.e. HTML.A and HTML.FORM elements) that advance the state of the current application.", "post_date":"2014-04-02 16:40:11", "url":"http://amundsen.com/hypermedia/profiles/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/alps-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Semantics", "Definitions", "Data Specifications"]}, {"tool_id":"727", "name":"API Blueprint", "user":"apiaryio", "details":"API Blueprint is a documentation-oriented API description language. A couple of semantic assumptions over the plain Markdown. API Blueprint is perfect for designing your Web API and its comprehensive documentation but also for quick prototyping and collaboration. It is easy to learn and even easier to read; after all,​ it is just a form of plain text.", "post_date":"2015-05-14 12:42:22", "url":"https://github.com/apiaryio/api-blueprint/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":"629", "followers":"2155", "watchers":"2155", "tags":["Specification", "Design", "Definitions", "API Blueprint Core", "API Blueprint"]}, {"tool_id":"1088", "name":"api-blueprint", "user":"apiaryio", "details":"API Blueprint", "post_date":"2016-07-17 15:21:42", "url":"https://api.github.com/repos/apiaryio/api-blueprint", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1114", "followers":"3974", "watchers":"3974", "tags":["GitHub", "Definitions"]}, {"tool_id":"1180", "name":"api-spec-converter", "user":"stoplightio", "details":"This package helps to convert between different API specifications (Postman, Swagger, RAML, StopLigh", "post_date":"2016-07-17 22:51:09", "url":"https://api.github.com/repos/stoplightio/api-spec-converter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"3", "followers":"14", "watchers":"14", "tags":["GitHub", "Definitions", "Converter"]}, {"tool_id":"1505", "name":"api-spec-converter", "user":"lucybot", "details":"Convert API descriptions between popular formats such as OpenAPI(fka Swagger), RAML, API Blueprint, WADL, etc.", "post_date":"2017-02-17 19:32:03", "url":"https://github.com/lucybot/api-spec-converter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"23", "followers":"159", "watchers":"159", "tags":["GitHub", "Definitions"]}, {"tool_id":"87", "name":"Apiary Blueprint Parser", "user":"", "details":"A JavaScript parser of Apiary API blueprints. Uses Node.js then in browser, include the browser version of the parser in your web page or application using the script tag. To parse an API blueprint, just call the parse method and pass the blueprint as a parameter. The method will return an object representing the parsed blueprint or throw an exception if the input is invalid.", "post_date":"2013-06-12 18:42:12", "url":"https://github.com/apiaryio/blueprint-parser", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Parser", "Definitions", "API Blueprint"]}, {"tool_id":"145", "name":"APIs.json", "user":"", "details":"APIs are becoming a crucial part of the Web. Unfortunately however, it remains very difficult to determine the location of these APIs on servers around the Web. The only way to discover APIs and their properties is via human driven search through public search engines or in hand curated API Directory listings. While these methods work, neither can scale to the potentially hundreds of thousands and millions of APIs which will be published over the next few years.", "post_date":"2014-06-15 17:00:37", "url":"http://apisjson.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/apisdotjson.png", "forks":0, "followers":0, "watchers":0, "tags":["Discovery", "Definitions"]}, {"tool_id":"1464", "name":"Asset Description Metadata Schema (ADMS)", "user":"", "details":"ADMS is a profile of DCAT, used to describe&nbsp;semantic assets&nbsp;(or just Assets), defined as highly reusable metadata (e.g. xml schemata, generic data models) and reference data (e.g. code lists, taxonomies, dictionaries, vocabularies) that are used for eGovernment system development.", "post_date":"2016-12-01 11:37:14", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/w3c-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"823", "name":"Barrister RPC", "user":"", "details":"Barrister is a RPC system that uses an external interface definition (IDL) file to describe the interfaces and data structures that a component implements. It is similar to tools like Protocol Buffers, Thrift, Avro, and SOAP.", "post_date":"2015-07-30 23:36:22", "url":"http://barrister.bitmechanic.com/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/barrister-rpc.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"1199", "name":"certificate-transparency-rfcs", "user":"google", "details":"Certificate Transparency RFC", "post_date":"2016-07-17 23:23:45", "url":"https://api.github.com/repos/google/certificate-transparency-rfcs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"19", "followers":"41", "watchers":"41", "tags":["GitHub", "Encryption", "Definitions"]}, {"tool_id":"1168", "name":"chef-server-schema", "user":"chef", "details":"SQL Schema for the Open Source Chef Server", "post_date":"2016-07-17 22:39:38", "url":"https://api.github.com/repos/chef/chef-server-schema", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"1", "watchers":"1", "tags":["Schema", "GitHub", "Definitions"]}, {"tool_id":"1501", "name":"CKAN OpenAPI Spec", "user":"", "details":"", "post_date":"2017-02-13 21:00:29", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data", "CKAN"]}, {"tool_id":"155", "name":"Collection+JSON", "user":"", "details":"Collection+JSON is a JSON-based read/write hypermedia-type designed to support management and querying of simple collections.", "post_date":"2014-07-25 18:07:45", "url":"http://amundsen.com/media-types/collection/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"https://github.com/collection-json", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/madmen_icon_400x400.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"1509", "name":"connect-api-specification", "user":"square", "details":"", "post_date":"2017-02-17 19:42:08", "url":"https://github.com/square/connect-api-specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"7", "followers":"19", "watchers":"19", "tags":["OpenAPI Spec", "Implementations", "GitHub", "Definitions"]}, {"tool_id":"770", "name":"couchdb-api-blueprint", "user":"BigBlueHat", "details":"apiaryio API Blueprint of Apache CouchDBs API", "post_date":"2015-05-14 12:47:43", "url":"https://github.com/BigBlueHat/couchdb-api-blueprint/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1", "followers":"1", "watchers":"1", "tags":["GitHub", "Definitions", "Database", "CouchDB", "API Blueprint"]}, {"tool_id":"1495", "name":"CSV Dialect Description Format (CSVDDF)", "user":"", "details":"This RFC defines a simple JSON format to describe the various dialects of CSV files; it aims to deal with a reasonably large subset of the features which differ between dialects (terminator strings, quoting rules, escape rules, etc), and roughly to describe the union of the capabilities of Python&rsquo;s csv module, Ruby&rsquo;s CSV module, and the MySQL and Postgres bulk load facilities at the time of writing (February 2013).", "post_date":"2017-01-23 14:33:28", "url":"http://specs.frictionlessdata.io/csv-dialect/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Schema", "Definitions", "Data", "CSV"]}, {"tool_id":"1496", "name":"Data Package Identifiers", "user":"", "details":"Data Package Identifiers are small JSON-oriented structure or strings which identify a Data Package (and, usually, its location).", "post_date":"2017-01-23 14:34:51", "url":"http://specs.frictionlessdata.io/data-package-identifier/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Schema", "Identifiers", "Definitions", "Data"]}, {"tool_id":"1492", "name":"datapackagist", "user":"frictionlessdata", "details":"A web app for creating, editing and validating Data Packages.", "post_date":"2017-01-23 14:25:09", "url":"https://api.github.com/repos/frictionlessdata/datapackagist", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"7", "followers":"14", "watchers":"14", "tags":["GitHub", "Definitions", "Data"]}, {"tool_id":"973", "name":"Docson", "user":"lbovet", "details":"Documentation for your JSON types", "post_date":"2016-07-11 19:58:33", "url":"https://github.com/lbovet/docson", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"42", "followers":"250", "watchers":"250", "tags":["GitHub", "Definitions", "Data Specifications"]}, {"tool_id":"1467", "name":"European Union PSI Directive", "user":"", "details":"The Directive on the re-use of public sector information (Directive 2003/98/EC, known as the PSI Directive) entered into force on 31 December 2003. It was revised by Directive 2013/37/EU which entered into force on 17 July 2013. It focuses on the economic aspects of re-use of information rather than on the access of citizens to information. It encourages the Member States to make as much information available for re-use as possible. It addresses material held by public sector bodies in the Member States, at national, regional and local levels, such as&nbsp;ministries, state agencies, municipalities, as well as organisations funded for the most part by or under the control of public authorities (e.g. meteorological institutes). Since 2013 content held by museums, libraries and archives falls within the scope of application as well.", "post_date":"2016-12-01 11:44:12", "url":"https://ec.europa.eu/digital-single-market/legal-rules#revision-of-the-directive", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/european-commission.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Policy"]}, {"tool_id":"1493", "name":"Frictionless Data", "user":"", "details":"A Data Package (or DataPackage) is a coherent collection of data and possibly other assets in a single &lsquo;package&rsquo;. It provides the basis for convenient delivery, installation and management of datasets.", "post_date":"2017-01-23 14:30:37", "url":"http://specs.frictionlessdata.io/data-packages/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Definitions", "Data"]}, {"tool_id":"1465", "name":"G8 Open Data Charter", "user":"", "details":"The Open Data Charter sets out 5 strategic principles that all G8 members will act on. These include an expectation that all government data will be published openly by default, alongside principles to increase the quality, quantity and re-use of the data that is released. G8 members have also identified 14 high-value areas &ndash; from education to transport, and from health to crime and justice &ndash; from which they will release data. These will help unlock the economic potential of open data, support innovation and provide greater accountability.", "post_date":"2016-12-01 11:39:33", "url":"https://www.gov.uk/government/publications/open-data-charter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/Screen Shot 2016-12-01 at 11.40.25 AM.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Policy"]}, {"tool_id":"1534", "name":"gnostic", "user":"googleapis", "details":"Compile OpenAPI descriptions into equivalent Protocol Buffer representations. Profit.", "post_date":"2017-03-10 14:19:24", "url":"https://github.com/googleapis/gnostic", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"4", "followers":"24", "watchers":"24", "tags":["GitHub", "Design", "Definitions"]}, {"tool_id":"1511", "name":"go-swagger", "user":"go-swagger", "details":"Swagger 2.0 implementation for go", "post_date":"2017-02-17 22:26:14", "url":"https://github.com/go-swagger/go-swagger", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"224", "followers":"971", "watchers":"971", "tags":["Parser", "GitHub", "Generator", "Definitions"]}, {"tool_id":"153", "name":"HAL", "user":"", "details":"HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Adopting HAL will make your API explorable, and its documentation easily discoverable from within the API itself. In short, it will make your API easier to work with and therefore more attractive to client developers. APIs that adopt HAL can be easily served and consumed using open source libraries available for most major programming languages. Its also simple enough that you can just deal with it as you would any other JSON.", "post_date":"2014-07-25 17:27:37", "url":"http://stateless.co/hal_specification.html", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/bw-github.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"820", "name":"Home Documents for HTTP APIs", "user":"", "details":"JSON Home Document is an HTTP API definition formated that follows the RFC4627 specification, and has the media type application/json-home.", "post_date":"2015-07-30 19:12:17", "url":"http://tools.ietf.org/html/draft-nottingham-json-home-02", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/ietf-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"69", "name":"I/O Docs", "user":"", "details":"I/O Docs is a live interactive documentation system for RESTful web APIs. By defining APIs at the resource, method and parameter levels in a JSON schema, I/O Docs will generate a JavaScript client interface. API calls can be executed from this interface, which are then proxied through the I/O Docs server with payload data cleanly formatted (pretty-printed if JSON or XML).", "post_date":"2013-02-02 20:12:13", "url":"https://github.com/mashery/iodocs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/io-docs-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Definitions"]}, {"tool_id":"824", "name":"Interpol", "user":"", "details":"Interpol is a toolkit for policing your HTTP JSON interface. To use it, define the endpoints of your HTTP API in simple YAML files. Interpol provides multiple tools to work with endpoint definitions.", "post_date":"2015-07-30 23:38:45", "url":"https://github.com/seomoz/interpol", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/interpol-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"1300", "name":"interpol", "user":"seomoz", "details":"A toolkit for working with API endpoint definition files, giving you a stub app, a schema validation", "post_date":"2016-07-25 23:21:44", "url":"https://api.github.com/repos/seomoz/interpol", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"13", "followers":"187", "watchers":"187", "tags":["GitHub", "Definitions"]}, {"tool_id":"815", "name":"JSON API", "user":"", "details":"If youve​ ever argued with your team about the way your JSON responses should be formatted, JSON API is your anti-bikeshedding weapon. By following shared conventions, you can increase productivity, take advantage of generalized tooling, and focus on what matters: your application. Clients built around JSON API are able to take advantage of its features around efficiently caching responses, sometimes eliminating network requests entirely.", "post_date":"2015-07-10 18:54:07", "url":"http://jsonapi.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-api-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Design", "Definitions"]}, {"tool_id":"827", "name":"JSON Schema", "user":"", "details":"Describes your JSON data format in clear, human- and machine-readable documentation that is complete structural validation, useful for automated testing, and validating client-submitted data.", "post_date":"2015-07-30 23:49:15", "url":"http://json-schema.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-schema.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"1494", "name":"JSON Table Schema", "user":"", "details":"This RFC defines a simple schema for tabular data. The schema is designed to be expressible in JSON.", "post_date":"2017-01-23 14:31:56", "url":"http://specs.frictionlessdata.io/json-table-schema/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/frictionlessdata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Schema", "Definitions", "Data Definitions", "Data"]}, {"tool_id":"1372", "name":"json-api", "user":"json-api", "details":"A specification for building JSON APIs", "post_date":"2016-08-04 18:12:37", "url":"https://github.com/json-api/json-api", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"449", "followers":"3914", "watchers":"3914", "tags":["GitHub", "Definitions"]}, {"tool_id":"167", "name":"JSON-LD", "user":"", "details":"JSON-LD is a lightweight Linked Data format. It is easy for humans to read and write. It is based on the already successful JSON format and provides a way to help JSON data interoperate at Web-scale. JSON-LD is an ideal data format for programming environments, REST Web services, and unstructured databases such as CouchDB and MongoDB.", "post_date":"2014-12-19 10:57:24", "url":"http://json-ld.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/json-ld.png", "forks":0, "followers":0, "watchers":0, "tags":["Semantics", "Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"828", "name":"JSON-RPC 2.0", "user":"", "details":"JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over http, or in many various message passing environments. It uses JSON (RFC 4627) as data format.", "post_date":"2015-07-30 23:53:52", "url":"http://www.jsonrpc.org/specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-rpc.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"1531", "name":"json-viewer", "user":"tulios", "details":"It is a Chrome extension for printing JSON and JSONP.", "post_date":"2017-03-04 21:02:03", "url":"https://github.com/tulios/json-viewer", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"103", "followers":"496", "watchers":"496", "tags":["GitHub", "Definitions"]}, {"tool_id":"1489", "name":"jsontableschema-js", "user":"frictionlessdata", "details":"A utility library for working with JSON Table Schema in Javascript.", "post_date":"2017-01-23 14:21:43", "url":"https://api.github.com/repos/frictionlessdata/jsontableschema-js", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"5", "followers":"13", "watchers":"13", "tags":["Schema", "JSON", "GitHub", "Definitions", "Data"]}, {"tool_id":"1159", "name":"loopback-connector-swagger", "user":"strongloop", "details":"Connect Loopback to a Swagger-compliant API", "post_date":"2016-07-17 22:31:38", "url":"https://api.github.com/repos/strongloop/loopback-connector-swagger", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"1", "watchers":"1", "tags":["GitHub", "Definitions"]}, {"tool_id":"825", "name":"Markdown Syntax for Object Notation (MSON)", "user":"", "details":"MSON is a plain-text, human and machine readable, description format for describing data structures in common markup formats such as JSON, XML or YAML.", "post_date":"2015-07-30 23:40:36", "url":"https://github.com/apiaryio/mson", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Specifications"]}, {"tool_id":"168", "name":"Mason", "user":"", "details":"Mason is a JSON format for introducing hypermedia elements to classic JSON data representations. With Mason, you get hypermedia elements for linking and modifying data, features for communicating to client developers and standardized error handling. Mason is built on JSON, reads JSON, writes JSON and generally fits well into a JSON based eco-system.", "post_date":"2014-12-19 10:59:17", "url":"https://github.com/JornWildt/Mason", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/jorn-wildt.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"1119", "name":"ODataSamples", "user":"odata", "details":"Samples: For ODataLib, OData Web API, RESTier, etc.", "post_date":"2016-07-17 20:07:30", "url":"https://api.github.com/repos/OData/ODataSamples", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"76", "followers":"68", "watchers":"68", "tags":["GitHub", "Definitions"]}, {"tool_id":"821", "name":"Open Data Protocol (OData)", "user":"", "details":"OData (Open Data Protocol) is an OASIS standard that defines the best practice for building and consuming RESTful APIs. OData helps you focus on your business logic while building RESTful APIs without having to worry about the approaches to define request and response headers, status codes, HTTP methods, URL conventions, media types, payload formats and query options etc.", "post_date":"2015-07-30 22:03:30", "url":"http://www.odata.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/odata-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Design", "Definitions", "Data Specifications", "Data Specification"]}, {"tool_id":"845", "name":"OpenAPI Specification", "user":"OAI", "details":"The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. Similar to what interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service.", "post_date":"2016-03-11 23:16:54", "url":"https://github.com/OAI/OpenAPI-Specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/openapi-spec.png", "forks":"940", "followers":"3107", "watchers":"3107", "tags":["Specification", "GitHub", "Design", "Definitions"]}, {"tool_id":"1504", "name":"OpenAPI-Specification", "user":"OAI", "details":"The OpenAPI Specification Repository", "post_date":"2017-02-17 19:31:51", "url":"https://github.com/OAI/OpenAPI-Specification", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1671", "followers":"5672", "watchers":"5672", "tags":["GitHub", "Definitions"]}, {"tool_id":"752", "name":"Paw API Blueprint Generator", "user":"apiaryio", "details":"Paw extension providing support to export API Blueprint as a code generator, allowing for you to publish API definitions from the web API client tooling.", "post_date":"2015-05-14 12:45:02", "url":"https://github.com/apiaryio/Paw-APIBlueprintGenerator/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/paw-api-client.png", "forks":"1", "followers":"10", "watchers":"10", "tags":["Generator", "Definitions", "Clients", "API Blueprint"]}, {"tool_id":"1172", "name":"Paw-PostmanEnvironmentImporter", "user":"luckymarmot", "details":"A Paw Extension to import Postman Environments.", "post_date":"2016-07-17 22:46:27", "url":"https://api.github.com/repos/luckymarmot/Paw-PostmanEnvironmentImporter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"5", "watchers":"5", "tags":["GitHub", "Definitions", "Clients"]}, {"tool_id":"1173", "name":"Paw-PostmanImporter", "user":"luckymarmot", "details":"A Paw Extension to import Postman Collections.", "post_date":"2016-07-17 22:46:42", "url":"https://api.github.com/repos/luckymarmot/Paw-PostmanImporter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"5", "watchers":"5", "tags":["GitHub", "Definitions", "Clients"]}, {"tool_id":"1171", "name":"Paw-WADLImporter", "user":"luckymarmot", "details":"WADL Importer for Paw", "post_date":"2016-07-17 22:46:04", "url":"https://api.github.com/repos/luckymarmot/Paw-WADLImporter", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"0", "watchers":"0", "tags":["GitHub", "Definitions", "Clients"]}, {"tool_id":"826", "name":"Postman Collections", "user":"", "details":"A collection lets you group individual requests together. These requests can be further organized into folders to accurately mirror your API. Requests can also store sample responses when saved in a collection. You can add metadata like name and description too so that all the information that a developer needs to use your API is available easily.", "post_date":"2015-07-30 23:44:35", "url":"https://www.getpostman.com/docs/collections", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/postman-rest-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Definitions"]}, {"tool_id":"1466", "name":"President Obama Executive Order", "user":"", "details":"Under the terms of the Executive Order and a new&nbsp;Open Data Policy&nbsp;released today by the Office of Science and Technology Policy and the Office of Management and Budget, all newly generated government data will be required to be made available in open, machine-readable formats, greatly enhancing their accessibility and usefulness, while ensuring privacy and security.", "post_date":"2016-12-01 11:42:13", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/white-house-logo-2.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Definitions", "Data Policy"]}, {"tool_id":"1179", "name":"prism", "user":"stoplightio", "details":"Turn any OAS (Swagger 2) file into an API server with mocking, transformations, validations, and mor", "post_date":"2016-07-17 22:50:49", "url":"https://api.github.com/repos/stoplightio/prism", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"3", "followers":"7", "watchers":"7", "tags":["Proxy", "GitHub", "Definitions"]}, {"tool_id":"1507", "name":"public_api_specs", "user":"NYTimes", "details":"The API Specs (in OpenAPI/Swagger) for the APIs available from developer.nytimes.com", "post_date":"2017-02-17 19:32:59", "url":"https://github.com/NYTimes/public_api_specs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"11", "followers":"59", "watchers":"59", "tags":["Implementations", "GitHub", "Definitions"]}, {"tool_id":"810", "name":"RAML Specification", "user":"", "details":"RESTful API Modeling Language (RAML) is a simple and succinct way of describing practically-RESTful APIs. It encourages reuse, enables discovery and pattern-sharing, and aims for merit-based emergence of best practices. The goal is to help our current API ecosystem by solving immediate problems and then encourage ever-better API patterns. RAML is built on broadly-used standards such as YAML and JSON and is a non-proprietary, vendor-neutral open spec.", "post_date":"2015-06-30 14:05:03", "url":"http://raml.org", "blog_url":"http://blog.raml.org/", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/raml-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "RAML", "Design", "Definitions"]}, {"tool_id":"1176", "name":"raml2postman", "user":"postmanlabs", "details":"Coverts RAML specs to Postman Collections (v1 of the collection format)", "post_date":"2016-07-17 22:48:54", "url":"https://api.github.com/repos/postmanlabs/raml2postman", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"2", "followers":"12", "watchers":"12", "tags":["GitHub", "Definitions", "Conversion", "Clients"]}, {"tool_id":"1462", "name":"ReDoc", "user":"Rebilly", "details":"OpenAPI/Swagger-generated API Reference Documentation", "post_date":"2016-09-28 20:22:54", "url":"https://github.com/Rebilly/ReDoc", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"24", "followers":"217", "watchers":"217", "tags":["GitHub", "Definitions"]}, {"tool_id":"829", "name":"RESTdesc", "user":"", "details":"Semantic descriptions for hypermedia APIs. RESTdesc allows you to capture the functionality of hypermedia APIs, so automated agents can use them. Despite their powerful capabilities, RESTdesc descriptions are easy to master. The description is not a goal in itself: you want your API to be used. See how RESTdesc opens up your API for discovery, based on its functional characteristics.", "post_date":"2015-07-31 00:00:13", "url":"http://restdesc.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/restdesc-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"818", "name":"RESTful API Description Language (RADL)", "user":"", "details":"RESTful API Description Language (RADL) is an XML vocabulary for describing Hypermedia-driven RESTful APIs. Unlike most HTTP API description languages, RADL focuses on defining a truly hypermedia-driven REST API from the clients point of view. Unlike description languages based on JSON or Markdown, RADL makes it easy to integrate documentation written in HTML or XML. The APIs that RADL describes may use any media type, in XML, JSON, HTML, or any other format.", "post_date":"2015-07-11 16:49:06", "url":"https://github.com/restful-api-description-language/RADL", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/radl-logo.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"124", "name":"RESTful API Modeling Language", "user":"", "details":"RESTful API Modeling Language (RAML) is a simple and succinct way of describing practically-RESTful APIs. It encourages reuse, enables discovery and pattern-sharing, and aims for merit-based emergence of best practices. The goal is to help our current API ecosystem by solving immediate problems and then encourage ever-better API patterns. RAML is built on broadly-used standards such as YAML and JSON and is a non-proprietary, vendor-neutral open spec.", "post_date":"2013-12-22 23:45:15", "url":"http://raml.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/raml-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Definitions"]}, {"tool_id":"822", "name":"RESTful Service Description Language (RSDL)", "user":"", "details":"The RESTful Service Description Language (RSDL) is a machine- and human-readable XML description of HTTP-based web applications (typically REST web services).", "post_date":"2015-07-30 23:12:42", "url":"http://www.balisage.net/Proceedings/vol10/html/Robie01/BalisageVol10-Robie01.html", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/rsdl-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"140", "name":"Rspec APIBlueprint", "user":"", "details":"Autogeneration of API documentation using the Blueprint format from request specs.", "post_date":"2014-06-15 13:13:42", "url":"https://github.com/playround/rspec_api_blueprint", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/api-blueprint.png", "forks":0, "followers":0, "watchers":0, "tags":["Generator", "Generation", "Definitions"]}, {"tool_id":"814", "name":"Schema.org", "user":"", "details":"Schema.org is a collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet, on web pages, in email messages, and beyond. Schema.org vocabulary can be used with many different encodings, including RDFa, Microdata and JSON-LD.", "post_date":"2015-07-10 17:39:35", "url":"http://schema.org/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/schema-org-logo.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Definitions"]}, {"tool_id":"1177", "name":"schemas", "user":"postmanlabs", "details":"Repository of all schemas for JSON structures compatible with Postman (such as the Postman Collectio", "post_date":"2016-07-17 22:49:13", "url":"https://api.github.com/repos/postmanlabs/schemas", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"8", "followers":"4", "watchers":"4", "tags":["Schemas", "GitHub", "Definitions"]}, {"tool_id":"1491", "name":"schemas", "user":"frictionlessdata", "details":"JSON Schemas, and a registry, for the Data Package family of specifications.", "post_date":"2017-01-23 14:24:24", "url":"https://api.github.com/repos/frictionlessdata/schemas", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"8", "followers":"16", "watchers":"16", "tags":["GitHub", "Definitions", "Data Schemas"]}, {"tool_id":"1484", "name":"serverless-swagger-plugin", "user":"serverless", "details":"", "post_date":"2017-01-13 23:17:15", "url":"https://github.com/serverless/serverless-swagger-plugin", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"1", "followers":"18", "watchers":"18", "tags":["Serverless", "GitHub", "Deployment", "Definitions"]}, {"tool_id":"1485", "name":"serverless_swagger", "user":"Reckon-Limited", "details":"Configure serverless functions from swagger definition", "post_date":"2017-01-13 23:17:51", "url":"https://github.com/Reckon-Limited/serverless_swagger", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"5", "watchers":"5", "tags":["Serverless", "GitHub", "Deployment", "Definitions"]}, {"tool_id":"166", "name":"Siren", "user":"", "details":"Siren is a hypermedia specification for representing entities. As HTML is used for visually representing documents on a Web site, Siren is a specification for presenting entities via a Web API. Siren offers structures to communicate information about entities, actions for executing state transitions, and links for client navigation.", "post_date":"2014-12-19 10:54:55", "url":"", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/kevin-swiber.jpeg", "forks":0, "followers":0, "watchers":0, "tags":["Media Type", "Hypermedia", "Design", "Definitions"]}, {"tool_id":"1335", "name":"skinfer", "user":"scrapinghub", "details":"Skinfer is a tool for inferring and merging JSON schemas", "post_date":"2016-07-26 00:06:44", "url":"https://api.github.com/repos/scrapinghub/skinfer", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"6", "followers":"48", "watchers":"48", "tags":["Merging", "GitHub", "Definitions"]}, {"tool_id":"731", "name":"Snowcrash", "user":"apiaryio", "details":"Snow Crash is the reference API Blueprint parser built on top of the Sundown Markdown parser.", "post_date":"2015-05-14 12:42:39", "url":"https://github.com/apiaryio/snowcrash/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png", "forks":"42", "followers":"265", "watchers":"265", "tags":["Parser", "GitHub", "Definitions", "API Blueprint Core", "API Blueprint"]}, {"tool_id":"1490", "name":"specs", "user":"frictionlessdata", "details":"Specifications for Frictionless Data.", "post_date":"2017-01-23 14:22:19", "url":"https://api.github.com/repos/frictionlessdata/specs", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"48", "followers":"264", "watchers":"264", "tags":["GitHub", "Definitions"]}, {"tool_id":"1508", "name":"spectacle", "user":"sourcey", "details":"Beautiful static documentation generator for OpenAPI/Swagger 2.0", "post_date":"2017-02-17 19:40:21", "url":"https://github.com/sourcey/spectacle", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"16", "followers":"42", "watchers":"42", "tags":["OpenAPI Spec", "Open API Initiative", "OAI", "GitHub", "Definitions"]}, {"tool_id":"1181", "name":"swagger-editor", "user":"swagger-hub", "details":"Swagger Editor", "post_date":"2016-07-17 22:51:45", "url":"https://api.github.com/repos/swagger-hub/swagger-editor", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"0", "watchers":"0", "tags":["IDE", "GitHub", "Definitions"]}, {"tool_id":"1182", "name":"swagger-ui", "user":"swagger-hub", "details":"Swagger UI is a dependency-free collection of HTML, Javascript, and CSS assets that dynamically gene", "post_date":"2016-07-17 22:52:03", "url":"https://api.github.com/repos/swagger-hub/swagger-ui", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"0", "followers":"0", "watchers":"0", "tags":["GitHub", "Documentation", "Definitions"]}, {"tool_id":"1178", "name":"swagger2-to-postman", "user":"postmanlabs", "details":"Converter for swagger 2.0 JSON to Postman Collection", "post_date":"2016-07-17 22:49:47", "url":"https://api.github.com/repos/postmanlabs/swagger2-to-postman", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"12", "followers":"21", "watchers":"21", "tags":["GitHub", "Definitions", "Conversion", "Clients"]}, {"tool_id":"139", "name":"Swagger2RAML", "user":"", "details":"A utility to generate RAML documentation from OpenAPI Specification.", "post_date":"2014-06-15 13:09:11", "url":"https://github.com/8x8Cloud/swagger2raml", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/raml-logo.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Swagger", "Definitions", "Converter"]}, {"tool_id":"1486", "name":"swaggy-lambda", "user":"mjgillespie", "details":"A toolkit to make serverless swagger-based REST services simple using AWS API Gateway and Lambda", "post_date":"2017-01-13 23:18:17", "url":"https://github.com/mjgillespie/swaggy-lambda", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"2", "followers":"32", "watchers":"32", "tags":["Serverless", "GitHub", "Deployment", "Definitions"]}, {"tool_id":"1162", "name":"tyk-swagger-definitions", "user":"TykTechnologies", "details":"Tyk swagger (OpenAPI) definition files", "post_date":"2016-07-17 22:35:09", "url":"https://api.github.com/repos/TykTechnologies/tyk-swagger-definitions", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"https://s3.amazonaws.com/kinlane-productions/bw-icons/bw-github.png", "forks":"2", "followers":"0", "watchers":"0", "tags":["OpenAPI Spec", "Management", "Implementations", "GitHub", "Gateways", "Deployment", "Definitions"]}, {"tool_id":"154", "name":"UBER", "user":"", "details":"The Uber message format is a minimal read/write hypermedia type designed to support simple state transfers and ad-hoc hypermedia-based transitions. This document describes both the XML and JSON variants of the format and provides guidelines for supporting Uber messages over the HTTP protocol.", "post_date":"2014-07-25 18:05:16", "url":"https://rawgit.com/mamund/media-types/master/uber-hypermedia.html", "blog_url":"", "blog_rss_url":"", "twitter_url":"http://twitter.com/uberhypermedia ", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/madmen_icon_400x400.jpg", "forks":0, "followers":0, "watchers":0, "tags":["Hypermedia", "Design", "Definitions"]}, {"tool_id":"817", "name":"Web Application Description Language (WADL)", "user":"", "details":"The Web Application Description Language (WADL) is a machine-readable XML description of HTTP-based web applications (typically REST web services). WADL models the resources provided by a service and the relationships between them. WADL is intended to simplify the reuse of web services that are based on the existing HTTP architecture of the Web. It is platform and language independent and aims to promote reuse of applications beyond the basic use in a web browser.", "post_date":"2015-07-11 16:36:02", "url":"https://wadl.java.net/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wadl-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}, {"tool_id":"844", "name":"Web Resource Modeling Language (WRML)", "user":"wrml", "details":"WRML, the Web Resource Modeling Language, is a domain-specific modeling language thats oriented toward the design of REST APIs.", "post_date":"2016-03-11 22:25:09", "url":"http://tool.api.kinlane.com/tool/fromgithub/", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wrml-logo.png", "forks":"7", "followers":"13", "watchers":"13", "tags":["Specification", "GitHub", "Design", "Definitions"]}, {"tool_id":"816", "name":"Web Services Description Language (WSDL)", "user":"", "details":"WSDL is an XML format for describing network services as a set of endpoints operating on messages containing either document-oriented or procedure-oriented information. The operations and messages are described abstractly, and then bound to a concrete network protocol and message format to define an endpoint. Related concrete endpoints are combined into abstract endpoints (services). WSDL is extensible to allow description of endpoints and their messages regardless of what message formats or network protocols are used to communicate, however, the only bindings described in this document describe how to use WSDL in conjunction with SOAP 1.1, HTTP GET/POST, and MIME.", "post_date":"2015-07-11 16:31:23", "url":"http://www.w3.org/TR/wsdl", "blog_url":"", "blog_rss_url":"", "twitter_url":"", "github_url":"", "logo":"http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wsdl-icon.png", "forks":0, "followers":0, "watchers":0, "tags":["Specification", "Design", "Definitions"]}]
